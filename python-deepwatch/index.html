<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <!-- <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" /> -->
  <meta content="width=device-width" name="viewport"/>
  <link href="/8bitcc_48x.png" rel="icon" type="image/png"/>
  <meta content="$ilp.uphold.com/MGN2ni2YMXaQ" name="monetization" property="monetization"/>
  <link href="/furo-purge.css" rel="stylesheet"/>
  <link href="/monokai.css" rel="stylesheet"/>
  <link href="/archive-styles.css" rel="stylesheet"/>
  <title>
   python-deepwatch
  </title>
  <meta content="article" name="og:type" property="og:type"/>
  <meta content="Waylon Walker" name="og:author" property="og:author"/>
  <meta content="Waylon Walker" name="og:site_name" property="og:site_name"/>
  <meta content="Is it possible to deep watch a single python function for changes? keeping track of a python functions hash is quite simple.  There is a__hash__ method attached to every python function.  Calling it will return a hash of the function. If the function" name="description" property="description"/>
  <meta content="Is it possible to deep watch a single python function for changes? keeping track of a python functions hash is quite simple.  There is a__hash__ method attached to every python function.  Calling it will return a hash of the function. If the function" name="og:description" property="og:description"/>
  <meta content="Is it possible to deep watch a single python function for changes? keeping track of a python functions hash is quite simple.  There is a__hash__ method attached to every python function.  Calling it will return a hash of the function. If the function" name="twitter:description" property="twitter:description"/>
  <meta content="python-deepwatch" name="og:title" property="og:title"/>
  <meta content="python-deepwatch" name="twitter:title" property="twitter:title"/>
  <meta content="python-deepwatch" name="title" property="title"/>
  <link href="/manifest.json" rel="manifest"/>
 </head>
 <body>
  <nav>
   <ul>
    <li>
     <a href="https://waylonwalker.com">
      Home
     </a>
    </li>
    <li>
     <a href="https://waylonwalker.com/archive">
      Archive
     </a>
    </li>
    <li>
     <a aria-label="RSS" href="https://waylonwalker.com/rss">
      <svg class="icon" height="16" viewbox="0 0 24 24" width="16" xmlns="http://www.w3.org/2000/svg">
       <path d="M 4 4.44 v 2.83 c 7.03 0 12.73 5.7 12.73 12.73 h 2.83 c 0 -8.59 -6.97 -15.56 -15.56 -15.56 Z m 0 5.66 v 2.83 c 3.9 0 7.07 3.17 7.07 7.07 h 2.83 c 0 -5.47 -4.43 -9.9 -9.9 -9.9 Z M 6.18 15.64 A 2.18 2.18 0 0 1 6.18 20 A 2.18 2.18 0 0 1 6.18 15.64" fill="currentColor">
       </path>
      </svg>
     </a>
    </li>
   </ul>
  </nav>
  <article class="blog-post h-entry">
   <p>
    Is it possible to deep watch a single python function for changes?
   </p>
   <h2>
    Shallow Watch
   </h2>
   <p>
    keeping track of a python functions hash is quite simple.  There is a
    <code>
     __hash__
    </code>
    method attached to every python function.  Calling it will return a hash of the function. If the function changes the hash will change.
   </p>
   <pre class="highlight"><code class="language-python">[ins] In [1]: def test():
         ...:     return "hello"

[ins] In [2]: test.__hash__()
Out[2]: 8760526380347

[ins] In [3]: test.__hash__()
Out[3]: 8760526380347

[ins] In [4]: def test():
         ...:     return "hello world"

[ins] In [5]: test.__hash__()
Out[5]: 8760525617988

[ins] In [6]: def test():
         ...:     return "hello"

[ins] In [7]: test.__hash__()
Out[7]: 8760526380491</code></pre>
   <p>
    Using hashlib provides a consistent hash.
   </p>
   <p>
   </p>
   <pre class="highlight"><code class="language-python">import inspect
import hashlib
def test():
    return "hello"

[ins] In [17]: m.update(inspect.getsource(test).encode())

[ins] In [18]: m
Out[18]: &lt;sha256 HASH object @ 0x7f7b7b70fde0&gt;

[ins] In [19]: m.hexdigest()
Out[19]: '1f2ff4c69eb69b545469686edd6f849136e104cd535785891586d90620328757'

[ins] In [20]: m.update(inspect.getsource(test).encode())

[ins] In [21]: m.hexdigest()
Out[21]: '93638f2c944f34a9069af9242657b7de556fcc63742f4c27c4c8deedeb976a5f'

[ins] In [22]: m = hashlib.sha256()

[ins] In [23]: m.update(inspect.getsource(test).encode())

[ins] In [24]: m.update(inspect.getsource(test).encode())

[ins] In [25]: m = hashlib.sha256()

[ins] In [26]: m.update(inspect.getsource(test).encode())

[ins] In [27]: m.hexdigest()
Out[27]: '1f2ff4c69eb69b545469686edd6f849136e104cd535785891586d90620328757'

[ins] In [28]: def test():
          ...:     return "hello world"

[ins] In [29]: m = hashlib.sha256()

[ins] In [30]: m.update(inspect.getsource(test).encode())

[ins] In [31]: m.hexdigest()
Out[31]: '121fa3a3f295d49d4609505bc5e96d8b6a8ed3b496e4f3dc6c0ead73bef4e3c7'

[ins] In [32]: def test():
          ...:     return "hello"

[ins] In [33]: m = hashlib.sha256()

[ins] In [34]: m.update(inspect.getsource(test).encode())

[ins] In [35]: m.hexdigest()
Out[35]: '1f2ff4c69eb69b545469686edd6f849136e104cd535785891586d90620328757'</code></pre>
   Now we have a consistent way to hash function code.
   <h2>
    Deep hashing
   </h2>
   <h3>
    Find dependencies
   </h3>
   <p>
    setup a function in a module with a dependency
   </p>
   <pre class="highlight"><code class="language-python">       │ File: one.py
───────┼────────────────────────────────
   1   │ def one():
   2   │     return 1
   3   │
   4   │ def two():
   5   │     return one() + one()</code></pre>
   <pre class="highlight"><code class="language-python">&gt;&gt;&gt; import one
&gt;&gt;&gt; one.one.__code__.co_names
()
&gt;&gt;&gt; one.two.__code__.co_names
('one', )</code></pre>
   <h2>
    Create Generic module importer by filepath
   </h2>
   <pre class="highlight"><code class="language-python">import importlib
import importlib.util
import os

def _import(path: Path, directory: Path, verbose: bool = False):
    """dynamically imports module given a path"""
    cwd = os.getcwd()
    os.chdir(directory)
    name = path.name
    # path = str(path).replace(str(directory) + "/", "")
    path = _make_path_relative(path, directory)
    try:
        spec = importlib.util.spec_from_file_location(name, path)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
    except (ModuleNotFoundError, ValueError):
        module = _use_importmodule(
            str(path).replace(os.sep, ".").replace(".py", ""), verbose=verbose
        )
    os.chdir(cwd)

    return module


def _use_importmodule(path: Path, verbose: bool = False):
    """
    relative imports do not work well with importlib.util.spec_from_file_location,
    and require a sys.path.append to be imported correctly.  For this reason
    importlib.import_module is the second option.
    """

    # Not sure if this is needed, but it was never hit in a test
    # if path[0] == ".":
    #     path = path[1:]

    sys.path.append(os.getcwd())
    mod = importlib.import_module(path)
    sys.path.pop()  # clean up path, do not permananatly change users path
    return mod
</code></pre>
   <h3>
    get code of dependency
   </h3>
   <p>
    the inspect module can tell us the filename of our current module.
   </p>
   <pre class="highlight"><code class="language-python">import inspect
module_path = inspect.getfile(one.one)
module = _import(module_path)</code></pre>
   <p>
    now we can hash the dependency
   </p>
   <pre class="highlight"><code class="language-python">nested_function = eval(f'module.{one.two.__code__.co_names[0]}"</code></pre>
   <div id="show">
   </div>
  </article>
 </body>
 <script>
  if ('serviceWorker' in navigator) {
  window.addEventListener('load', function() {
    navigator.serviceWorker.register('/service-worker.js').then(function(registration) {
      // Registration was successful
      console.log('ServiceWorker registration successful with scope: ', registration.scope);
    }, function(err) {
      // registration failed :(
      console.log('ServiceWorker registration failed: ', err);
    });
  });
}
 </script>
</html>